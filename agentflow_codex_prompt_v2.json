{
  "title": "AgentFlow Codex Prompt",
  "version": "2.0",
  "author": "Агенты / AgentFlow",
  "modules": [
    {
      "phase": 0,
      "title": "SYSTEM INIT (ENTRY POINT)",
      "prompt": "You are an expert full-stack AI engineer and software architect. Build a Windows desktop app called \"AgentFlow Desktop\" — a modular multi-agent platform for AI marketing automation. Users must configure everything from UI (no code edits). Architecture: Electron + Node.js (ESM) + React (Vite) + SQLite (better-sqlite3) + Telegram bot + plugin-based agents. Generate the project in 6 phases and validate each phase with the given checklist. Environment: Node >= 20, Electron >= 31, Windows 10/11. Output style: Markdown folder trees + code blocks; concise, real code; comments in English; UI labels in Russian."
    },
    {
      "phase": 1,
      "title": "ARCHITECTURE SCAFFOLDING",
      "prompt": "### PHASE 1 — SCAFFOLD\\nGoal: create runnable scaffold.\\nCreate folder structure:\\napp/\\n ├─ main/                # Electron main process (windows, preload, IPC)\\n ├─ renderer/            # React UI (Vite build to dist/)\\n ├─ core/                # Orchestrator, plugin loader, agents\\n ├─ services/            # Telegram bot (optional), local mini-API\\n ├─ data/                # SQLite DB, artifacts, logs\\n ├─ config/              # providers.json, settings\\n ├─ .env.example         # API keys refs\\n └─ package.json         # scripts + electron-builder config\\n\\npackage.json requirements:\\n- scripts: {\\n  \"dev\": \"cross-env NODE_ENV=development electron .\",\\n  \"build:ui\": \"cd renderer && npm run build\",\\n  \"build\": \"npm run build:ui && electron-builder\"\\n}\\n- build (electron-builder): appId, productName, asar=true, win.target=nsis, nsis.oneClick=false, directories.output=dist\\n- dependencies: electron, electron-builder, electron-updater, better-sqlite3, dotenv, keytar, cross-env\\n- devDependencies: vite, react, react-dom\\n\\nRenderer bootstrap: Vite + React minimal app with 3 tabs: «Проекты», «Агенты», «Пайплайны». Load index.html from renderer/dist.\\n\\nElectron main: create BrowserWindow, load file ../renderer/dist/index.html, preload exposes AgentAPI via IPC.\\n\\nChecklist ✅\\n- npm install succeeds\\n- npm run dev opens Electron window with Russian UI stub\\n- renderer built into renderer/dist\\n- main loads renderer/dist/index.html"
    },
    {
      "phase": 2,
      "title": "CORE & ORCHESTRATOR",
      "prompt": "### PHASE 2 — CORE\\nGoal: implement pipeline execution and context.\\nCreate core/orchestrator.js with functions:\\n- runPipeline(pipeline, input) executes graph nodes (task|guard|humanGate|router).\\n- Node schema: { id, agentName, kind, override?, retries? (default 1), onError? (\"fail\"|\"skip\"|\"route:<id>\") }.\\n- Edges: [{ from, to, condition? }]. If router, choose edges by condition.\\n- Context (ctx): { runId, project, env, getAgentConfig(name), log(event, data), setArtifact(relPath, Buffer|string|json), override? }.\\n- Logging: write JSONL to /data/logs/run_<id>.jsonl with entries {ts,event,data}.\\n- Artifacts: write to /data/artifacts/<runId>/... and return paths in payload._artifacts.\\n- Error handling: retry up to retries; if still failing → mark node.status=\"error\", stop pipeline, log error.\\n\\nCreate core/pluginLoader.js to auto-load agents from core/agents/* (each has manifest.json + index.js with export async function execute(payload, ctx)).\\n\\nCreate minimal core/api.js exposing IPC handlers: listAgents, upsertAgent, runPipelineSimple (for demo).\\n\\nChecklist ✅\\n- Orchestrator runs linear 2-node pipeline (Writer→Uploader) with simulated outputs\\n- Logs and artifacts appear in /data\\n- IPC calls from renderer succeed (listAgents, runPipelineSimple)"
    },
    {
      "phase": 3,
      "title": "AGENTS & PLUGINS",
      "prompt": "### PHASE 3 — AGENTS\\nGoal: plugin-based agents, no hardcoded texts. All behavior comes from agent configs and step overrides.\\nAgent folder structure:\\ncore/agents/<Type>/\\n ├─ manifest.json  # { name, version, description }\\n └─ index.js       # export async function execute(payload, ctx)\\n\\nBase config model for an agent (stored in SQLite and editable from UI):\\n{\\n  id, projectId, type, name, instructions,\\n  engine: { provider, model, temperature?, maxTokens? },\\n  params: { ... },\\n  templates: { ... },\\n  version, source: \"auto\"|\"manual\"\\n}\\n\\nImplement examples:\\n1) WriterAgent — uses simple templating ({{key}}) to render caption/title/scripts from templates. No static text in code. Input merges: payload → step.override → agent.params.\\n2) UploaderAgent — simulated upload: write text files per platform into artifacts, set status=\"simulated\".\\n3) StyleGuard — rule-based check (e.g., no medical claims). Returns { guard: { pass: true|false, reasons:[] } }.\\n4) HumanGate — returns { human: { required:true } } and waits for approval via a stub (simulate immediate approval in MVP).\\n\\nI/O Convention: execute(payload, ctx) returns updated payload (do not mutate in place).\\n\\nChecklist ✅\\n- Agents auto-load via pluginLoader\\n- Writer uses templates from config (no hardcoded copy)\\n- Uploader writes artifacts\\n- Guard produces pass/fail"
    },
    {
      "phase": 4,
      "title": "AI PROVIDERS & CONFIG",
      "prompt": "### PHASE 4 — PROVIDERS\\nGoal: configurable LLM/Image/Video providers, model selection in UI, overrides per step, fallbacks, mock offline mode.\\nCreate config/providers.json example:\\n{\\n  \"providers\": [\\n    { \"id\":\"openai\", \"type\":\"llm\", \"models\":[\"gpt-4o-mini\",\"gpt-4o\"], \"apiKeyRef\":\"OPENAI_API_KEY\" },\\n    { \"id\":\"gemini\", \"type\":\"llm\", \"models\":[\"gemini-2.0-flash\"], \"apiKeyRef\":\"GOOGLE_API_KEY\" },\\n    { \"id\":\"ollama\", \"type\":\"llm\", \"models\":[\"llama3.1:8b\"], \"baseUrl\":\"http://localhost:11434\" },\\n    { \"id\":\"stability\", \"type\":\"image\", \"models\":[\"sd3.5\"], \"apiKeyRef\":\"STABILITY_API_KEY\" },\\n    { \"id\":\"higgs\", \"type\":\"video\", \"models\":[\"studio-v\"], \"apiKeyRef\":\"HIGGSFIELD_API_KEY\" }\\n  ]\\n}\\n\\nKey storage: .env or Windows Credential Manager via keytar. UI only shows connection status (no raw keys).\\nSelection priority: step.override.engine → agent.engine → default provider.\\nFallbacks: agent.engine.fallback = [ {provider, model}, ... ].\\nOffline mode: if no keys, return mock JSON/images/videos and log \"mock\" in artifacts.\\n\\nProvide thin wrappers for OpenAI/Gemini fetch calls; for Ollama use local HTTP; for image/video return placeholders in MVP.\\n\\nChecklist ✅\\n- Provider resolver picks correct engine\\n- Missing key triggers mock mode (no crash)\\n- Override per step works and logged"
    },
    {
      "phase": 5,
      "title": "UI (RENDERER)",
      "prompt": "### PHASE 5 — UI\\nGoal: friendly UI where users configure everything without touching code. Tech: React + Vite; minimal styling with Tailwind or plain CSS.\\nSections (Russian labels):\\n1) «Проекты»: список проектов, создание, deeplink для бота.\\n2) «Бриф»: просмотр ответов (из бота), правки.\\n3) «Агенты»: список; карточка агента (instructions, engine provider/model, params, templates) с JSON-редактором и валидацией.\\n4) «Пайплайны»: визуальный граф (react-flow optional in later iteration; for MVP show linear list). Шаги с override JSON.\\n5) «Запуски»: кнопка «Запустить», список логов по шагам, ссылки на артефакты, кнопка «Одобрить» (HumanGate).\\n6) «Отчёты»: JSON-таблица и краткий текстовый summary.\\n7) «Настройки»: провайдеры (status ✓), локализация RU/EN, тема.\\n\\nIPC API exposed in preload: window.AgentAPI.listAgents(), upsertAgent(), listProjects(), upsertPipeline(), runPipeline(), getRunLogs(), getReports().\\n\\nUI requirements:\\n- Все тексты интерфейса на русском.\\n- Простые формы, подсказки (placeholder).\\n- Обработка ошибок (toast с сообщениями).\\n\\nChecklist ✅\\n- UI запускается\\n- Агенты редактируются без перезапуска\\n- Пайплайн сохраняется и запускается\\n- Логи отображаются; артефакты кликабельны"
    },
    {
      "phase": 6,
      "title": "PACKAGING, TESTING & BUILD",
      "prompt": "### PHASE 6 — BUILD & TEST\\nGoal: produce .exe installer and validate end-to-end flow.\\nElectron-builder config (in package.json): { appId, productName:\"AgentFlow\", files:[\"main/**/*\",\"core/**/*\",\"services/**/*\",\"renderer/dist/**/*\",\"data/**/*\",\"config/**/*\",\".env\"], asar:true, directories.output:\"dist\", win:{target:\"nsis\", icon:\"main/icon.ico\"}, nsis:{oneClick:false, allowToChangeInstallationDirectory:true, createDesktopShortcut:true, createStartMenuShortcut:true} }\\nAutoupdate (optional): electron-updater + GitHub Releases.\\n\\nTesting checklist ✅\\nFunctional:\\n- npm run dev launches app\\n- Create project, edit agent, create pipeline\\n- Run pipeline: Writer → Guard → HumanGate (auto approve) → Uploader\\n- Artifacts saved in /data/artifacts/<runId>\\n- Reports json generated\\nIntegration:\\n- If OPENAI_API_KEY missing, mock mode works\\n- Provider override per step works\\nSecurity:\\n- No keys in logs or code; .env ignored by git\\nBuild:\\n- npm run build creates dist/AgentFlowSetup.exe without errors\\n\\nFinal output: folder tree, key files (code blocks), README with setup & usage (RU), and notes for offline/online operation."
    }
  ]
}
